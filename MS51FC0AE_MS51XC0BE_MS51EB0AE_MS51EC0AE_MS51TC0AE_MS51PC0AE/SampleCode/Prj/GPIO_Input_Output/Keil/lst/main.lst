C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Users\Admin\AppData\Local\Keil_v5\C51\BIN\C51.EXE ..\main.c LARGE OMF2 OPTIMIZE(7,SPEED) BROWSE 
                    -INCDIR(..\..\..\..\Library\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\lst\main.lst) TABS(2) OBJECT(
                    -.\Output\main.obj)

line level    source

   1          #include "ms51_32k.h"
   2          #include "string.h"
   3          bit  ADC_CONT_FINAL_FLAG; 
   4          //define
   5          #define delay_ms(x) Timer0_Delay(24000000,x,1000) 
   6          #define delay_us(x) Timer0_Delay(24000000,x,100) 
   7          
   8          #define LED_GREEN P04
   9          #define LED_RED P05
  10          #define BEEP P12
  11          #define EN_WIFI P34
  12          
  13          #define KEYB P01
  14          #define KEYC P33
  15          #define RF_IN P03
  16          
  17          #define DC_ON P14
  18          #define CH_OFF P22
  19          #define BOOST_OFF P32
  20          
  21          #define RL1 P37
  22          #define RL2 P36
  23          #define RL3 P35
  24          #define RL4 P31
  25          
  26          #define BEEP_OFF BEEP = 0;
  27          #define BEEP_ON BEEP = 1;
  28          
  29          #define BELL_ON RL2 = 1;
  30          #define BELL_OFF RL2 = 0;
  31          
  32          #define PW_ACIN         0x01
  33          #define PW_BAT          0x02
  34          #define PW_CHARG        0x04
  35          #define BAT_OK          0x08
  36          
  37          #define ALARM           0x00
  38          #define NOT_USE         0x01 
  39          #define ENDOFLINE       0x02 
  40          #define NORMAL          0x03
  41          
  42          #define LINE16_K1           0x00
  43          #define LINE16_K2         0x01 
  44          
  45          char dataload[40];
  46          char HexString[73];
  47          int Tick = 0;
  48          //server
  49          char *test_mqttServer = "\"dev-api.lctech.vn\"";
  50          int   test_mqttPort = 1884;
  51          char *mqttUser = "\"lctech_dev\"";
  52          char *mqttPassword = "\"lctech_DEV@123\"";
  53          char *topicSever = "\"swm/g4/data\"";
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 2   

  54          char *txt_subscribe = "\"mmm/94E6862F1EA0/cmd\"";
  55          //char ESP_ID[15]; 
  56          char ESPID[15] ;
  57          char IMEI[20]; 
  58          char M[100];
  59          //uart interrupt
  60          unsigned char RxUART[100];
  61          unsigned int ID = 0;
  62          int update = 0; 
  63          
  64          #define numLine 16;
  65          struct gsafe_msg_data { 
  66            uint8_t alarmStatus;        //  1        
  67            uint16_t batVoltage;        //  2 
  68            unsigned int batPercent;         //  1 
  69            unsigned int pwStatus;           //  1 
  70            int Status;             //  1 
  71            unsigned int rssi4G;              //  1 
  72            unsigned int rssiWF;              //  1 
  73            unsigned int rssiInit;
  74            unsigned int lineStatus[16];
  75            int holdStatus[16];
  76            int keySensor[16],timeHold[16];
  77            int enableBell;   
  78          };
  79          struct gsafe_msg_data gdata ;
  80          //fucntion
  81          int Channel_Alarm[16];
  82          void Set_Channel_ADC(char kenh){
  83   1        //p16 p02 p15 p25
  84   1        P25 = (kenh)&0x01;
  85   1        P15 = (kenh>>1)&0x01;
  86   1        P02 = (kenh>>2)&0x01;
  87   1        P16 = (kenh>>3)&0x01;
  88   1      }
  89          void Set_Relay(int status){
  90   1        P37 = status;       //RL1
  91   1        P36 = status;
  92   1        P35 = status;
  93   1        P31 = status;
  94   1      }
  95          unsigned int readADC_Sensor(char channel){
  96   1        unsigned int ADCdataAIN;
  97   1        Set_Channel_ADC(channel);
  98   1        ENABLE_ADC_CH0;
  99   1        clr_ADCCON0_ADCF;
 100   1        set_ADCCON0_ADCS; // ADC start trig signal
 101   1        while(ADCF == 0);
 102   1        P35 ^= 1;
 103   1        ADCdataAIN = (ADCRH<<4)+(ADCRL&0x0F);
 104   1        DISABLE_ADC;
 105   1        return ADCdataAIN;
 106   1      }
 107          unsigned int adc[16];
 108          void readADC_16line(){
 109   1        int line;
 110   1        gdata.Status = NORMAL;
 111   1        for(line=0;line<16;line++){
 112   2          adc[line] = readADC_Sensor(line);
 113   2          //k mac tro: adc = 3400-3600
 114   2          //mac tro binh thuong: 3000
 115   2          //mac tro bao chay: <1000
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 3   

 116   2          if(adc[line] >3200){//not use
 117   3            Channel_Alarm[line] = 1;
 118   3            gdata.holdStatus[line] = NOT_USE;
 119   3            gdata.lineStatus[line]=NOT_USE;
 120   3          }
 121   2          else if (adc[line] <1000){//alarm
 122   3            Channel_Alarm[line] = 2;
 123   3            gdata.lineStatus[line]=ALARM;
 124   3            if(gdata.keySensor[line]!=ALARM){ 
 125   4                gdata.keySensor[line] = ALARM;
 126   4                gdata.timeHold[line] = 1;
 127   4            } else{
 128   4              gdata.timeHold[line]++;
 129   4              if(gdata.timeHold[line]>=5){
 130   5                gdata.timeHold[line]=5;
 131   5                gdata.holdStatus[line] = ALARM;
 132   5                gdata.Status = ALARM;  
 133   5              }
 134   4              } 
 135   3          }
 136   2          else {//normal
 137   3            Channel_Alarm[line] = 3;
 138   3            gdata.timeHold[line]=0;
 139   3            gdata.holdStatus[line] = NORMAL; 
 140   3            gdata.keySensor[line] = NORMAL;  
 141   3            gdata.lineStatus[line]=NORMAL;
 142   3          }
 143   2        }
 144   1      }
 145          
 146          
 147          void putc_UART0(unsigned int *mang, unsigned int n){
 148   1        unsigned int i;
 149   1        for(i=0;i<n;i++){
 150   2          UART_Send_Data(UART0,mang[i]);
 151   2        }
 152   1      }
 153          void putc_UART1(unsigned int *mang, unsigned int n){
 154   1        unsigned int i;
 155   1        for(i=0;i<n;i++){
 156   2          UART_Send_Data(UART1,mang[i]);
 157   2        }
 158   1      }
 159          void putc_UART2(unsigned int *mang, unsigned int n){
 160   1        unsigned int i;
 161   1        for(i=0;i<n;i++){
 162   2          UART2_Send_Data(mang[i]);
 163   2        }
 164   1      }
 165          void puts_UART0(char *chuoi){
 166   1        while(*chuoi){
 167   2          UART_Send_Data(UART0,*chuoi);
 168   2          chuoi++;
 169   2        }
 170   1      }
 171          void puts_UART1(char *chuoi){
 172   1        while(*chuoi){
 173   2          UART_Send_Data(UART1,*chuoi);
 174   2          chuoi++;
 175   2        }
 176   1      }
 177          void puts_UART2(char *chuoi){
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 4   

 178   1        while(*chuoi){
 179   2          UART2_Send_Data(*chuoi);
 180   2          chuoi++;
 181   2        }
 182   1      }
 183          
 184          void checkAlarm(){
 185   1        static int keyBell = 0;  
 186   1        static int stt = 1;     
 187   1        static int alarm = 0;
 188   1      
 189   1        if(gdata.Status == ALARM){
 190   2          if(alarm != ALARM){
 191   3            BELL_ON;
 192   3            BEEP_ON;
 193   3            keyBell = 1;
 194   3          }
 195   2          if(KEYB == 0 && stt == 1){
 196   3            if(keyBell){
 197   4              BELL_OFF;
 198   4              BEEP_OFF;
 199   4              keyBell = 0;
 200   4            } else {
 201   4              BELL_ON;
 202   4              BEEP_ON;
 203   4              keyBell = 1;
 204   4            }
 205   3          }
 206   2          RL1 = 1; RL3 = 1; 
 207   2          RL4= 1;
 208   2        }
 209   1        else {
 210   2          BELL_OFF;
 211   2          BEEP_OFF;
 212   2          //Set_Relay(0);
 213   2          RL1 = 0;
 214   2          RL2 = 0; 
 215   2      //    RL3 = 0;
 216   2          RL4 = 0;
 217   2          keyBell = 0;
 218   2        }
 219   1        stt = KEYB;
 220   1        alarm = gdata.Status;
 221   1      }
 222          
 223          
 224                
 225          unsigned int check_power(){
 226   1        unsigned int ac_ch;
 227   1        ENABLE_ADC_CH12;
 228   1        clr_ADCCON0_ADCF;
 229   1        set_ADCCON0_ADCS;
 230   1        while(ADCF == 0);
 231   1        P35 ^= 1;
 232   1        ac_ch = (ADCRH<<4)+(ADCRL&0x0F);
 233   1        DISABLE_ADC;
 234   1        return ac_ch;
 235   1      }
 236          unsigned int check_Vdc(){
 237   1        unsigned int value;
 238   1        ENABLE_ADC_CH13;
 239   1        clr_ADCCON0_ADCF;
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 5   

 240   1        set_ADCCON0_ADCS; 
 241   1        while(ADCF == 0);
 242   1        P35 ^= 1;
 243   1        value = (ADCRH<<4)+(ADCRL&0x0F);
 244   1        DISABLE_ADC;
 245   1        return value;
 246   1      }
 247          unsigned int check_Vbat(){
 248   1        unsigned int value;
 249   1        ENABLE_ADC_CH11;
 250   1        clr_ADCCON0_ADCF;
 251   1        set_ADCCON0_ADCS; 
 252   1        while(ADCF == 0);
 253   1        P35 ^= 1;
 254   1        value = (ADCRH<<4)+(ADCRL&0x0F);
 255   1        DISABLE_ADC;
 256   1        return value;
 257   1      }
 258          unsigned int check_IN16M(){
 259   1        unsigned int value;
 260   1        ENABLE_ADC_CH7;
 261   1        clr_ADCCON0_ADCF;
 262   1        set_ADCCON0_ADCS; 
 263   1        while(ADCF == 0);
 264   1        P35 ^= 1;
 265   1        value = (ADCRH<<4)+(ADCRL&0x0F);
 266   1        DISABLE_ADC;
 267   1        //1.65 
 268   1        if(value>1600){
 269   2          return LINE16_K2;
 270   2        }
 271   1        else{
 272   2          return LINE16_K1;
 273   2        }
 274   1      }
 275          void controlPower(){
 276   1              //control vdc,vbat
 277   1          unsigned int vbat_fb,vdc_fb,pw_fb;
 278   1          vbat_fb = check_Vbat(); // control 
 279   1          vdc_fb = check_Vdc();// control DC_ON
 280   1          pw_fb = check_power();
 281   1          gdata.pwStatus = 0;
 282   1          gdata.batPercent = (int)((vbat_fb-2700)/8);
 283   1          if(gdata.batPercent>100)gdata.batPercent=100;
 284   1          
 285   1          if(vdc_fb<2500){ //Vdc<23V
 286   2            BOOST_OFF = 0;
 287   2          } else {
 288   2            BOOST_OFF = 1;
 289   2          }
 290   1          if(vbat_fb<3500){//<8.4 open charge
 291   2              CH_OFF = 0; 
 292   2          }
 293   1          if( pw_fb>3700){
 294   2            gdata.pwStatus |= PW_BAT; 
 295   2      //      return 1;// khoong co AC
 296   2          } else if (pw_fb < 1600){
 297   2            gdata.pwStatus |= PW_ACIN;
 298   2            gdata.pwStatus |= BAT_OK;
 299   2      //      return 2; //co nguon AC, Pin
 300   2          } else {
 301   2            gdata.pwStatus |= PW_ACIN;
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 6   

 302   2            gdata.pwStatus |= PW_CHARG;
 303   2      //      return 3; // co AC, k pin
 304   2          }
 305   1      }
 306          
 307          
 308          unsigned char bufffer[100];
 309          //void Read_String0(char *buffer,unsigned char len){
 310          //  int i;
 311          //  unsigned char dt;
 312          //  for(i=0;i<len;i++){
 313          //    dt = Receive_Data(UART0);
 314          //    *buffer = dt;
 315          //    buffer++; 
 316          //  }
 317          //  *buffer = '\0';
 318          //}
 319          //void Read_String1(char *buffer,unsigned char len){
 320          //  int i;
 321          //  unsigned char dt;
 322          //  for(i=0;i<len;i++){
 323          //    dt = Receive_Data(UART1);
 324          //    *buffer = dt;
 325          //    buffer++; 
 326          //  }
 327          //  *buffer = '\0';
 328          //}
 329          //void ReadStringUntil0(unsigned char *buffer,unsigned char until, int max_length){
 330          //  int i;
 331          //  unsigned char dt;
 332          //  char *ptr = buffer;
 333          //  for(i=0;i<max_length;i++){
 334          //    dt = Receive_Data(UART0);
 335          //    if(dt == until) break;
 336          //    *ptr = dt;
 337          //    ptr+=1;
 338          //  }
 339          //  *ptr = '\0';
 340          //}
 341          //unsigned char Receive_Data0(unsigned int timeout)
 342          //{
 343          //    UINT8 c;
 344          //    //unsigned char c;
 345          //    PUSH_SFRS;
 346          //    SFRS = 0;
 347          //    while (!RI){
 348          //      if(Tick > timeout) return 0;
 349          //    }
 350          //    c = SBUF;
 351          //    RI = 0;
 352          //    POP_SFRS;
 353          //    return (c);
 354          //}
 355          //void ReadStringUntil00(unsigned char *buffer,unsigned char until, unsigned int timeout){
 356          //  int i;
 357          //  unsigned char dt;
 358          //  char *ptr = buffer;
 359          //  Tick = 0;
 360          //  while(Tick <= timeout){
 361          //    dt = Receive_Data0(timeout);
 362          //    if(dt == until) break;
 363          //    *ptr = dt;
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 7   

 364          //    ptr+=1;
 365          //  }
 366          //  *ptr = '\0';
 367          //}
 368          void ReadStringUntil(unsigned char *buffer,unsigned char until, int max_length){
 369   1        int i;
 370   1        unsigned char dt;
 371   1        char *ptr = buffer;
 372   1        for(i=0;i<max_length;i++){
 373   2          dt = Receive_Data(UART1);
 374   2          if(dt == until) break;
 375   2          *ptr = dt;
 376   2          ptr+=1;
 377   2        }
 378   1        *ptr = '\0';
 379   1      }
 380          //void ReadStringUntil1(unsigned char *buffer,unsigned char *rev, int max_length){
 381          //  int i;
 382          //  unsigned char dt;
 383          //  char *ptr = buffer;
 384          //  for(i=0;i<max_length;i++){
 385          //    dt = Receive_Data(UART1);
 386          //    if(strstr(ptr,rev)!=NULL) break;
 387          //    if(strstr(ptr,rev)=="ERR") break;
 388          //    *ptr = dt;
 389          //    ptr+=1;
 390          //  }
 391          //  *ptr = '\0';
 392          //}
 393          
 394          
 395          //int waitResponse1(unsigned char *buffer, unsigned char *expect_str,int timeout){
 396          ////  int i;
 397          //  int index = 0;
 398          //  unsigned char dt;
 399          //  Tick = 0;
 400          //  while (Tick < timeout){
 401          //    //if(RI_1==1){
 402          //    //while (!RI_1);
 403          //      dt = Receive_Data(UART1);
 404          //    UART2_Send_Data(dt);
 405          //    if (dt <= 0) continue;
 406          //    *buffer = dt;
 407          //    buffer++;
 408          //    //if(startMillis == 7 ) LED_GREEN = 0;
 409          //    if (strstr(buffer, expect_str) !=NULL) {
 410          //          index = 1;
 411          //          //goto finish;
 412          //          break;
 413          //    } else if (strstr(buffer, "ERROR") !=NULL) {
 414          //          index = 2;
 415          //         // goto finish;
 416          //          break;
 417          //    }
 418          //  }
 419          //  //finish: 
 420          //  //puts_UART2(buffer);
 421          //  Tick = 0;
 422          //    if(!index){
 423          //      sprintf(M,"%s\r\n",bufffer);
 424          //      puts_UART2(M);
 425          //    }
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 8   

 426          //  return index;
 427          //}
 428          void GPIO_Init(){
 429   1        MODIFY_HIRC(HIRC_24);
 430   1        //ALL_GPIO_QUASI_MODE;
 431   1        //SCON_1 = 0;
 432   1        P12_PUSHPULL_MODE;
 433   1        BEEP_OFF;
 434   1        P31_QUASI_MODE;
 435   1        P35_QUASI_MODE;
 436   1        P36_QUASI_MODE;
 437   1        P37_QUASI_MODE;
 438   1        Set_Relay(0);
 439   1        //wifi
 440   1        P34_PUSHPULL_MODE;
 441   1        //power
 442   1        P32_PUSHPULL_MODE;
 443   1        P14_PUSHPULL_MODE;
 444   1        P22_PUSHPULL_MODE;
 445   1      //  P32_QUASI_MODE;
 446   1      //  P14_QUASI_MODE;
 447   1      //  P22_QUASI_MODE;
 448   1        //led
 449   1        P04_PUSHPULL_MODE;
 450   1        P05_PUSHPULL_MODE;
 451   1        //sa
 452   1        P15_PUSHPULL_MODE;
 453   1        P16_PUSHPULL_MODE;
 454   1        P02_PUSHPULL_MODE;
 455   1        P25_PUSHPULL_MODE;
 456   1        //key
 457   1        P33_INPUT_MODE;
 458   1        P01_INPUT_MODE;
 459   1        P03_INPUT_MODE;
 460   1        //P32 P22 P14     P37 P36 P35 P31     P01  P33
 461   1      //  P31_PUSHPULL_MODE;
 462   1      //  P35_PUSHPULL_MODE;
 463   1      //  P36_PUSHPULL_MODE;
 464   1      //  P37_PUSHPULL_MODE;
 465   1      //  Set_Relay(0);
 466   1      //  RL1=0;
 467   1      //  RL2=0;
 468   1      //  RL3=0;
 469   1      //  RL4=0;
 470   1        ///uart 
 471   1        //0b10011111
 472   1        //AUXR2 = 0x9F;
 473   1        //SCON_1 |= 0x10;
 474   1        // uart2 - debug
 475   1        P30_QUASI_MODE;
 476   1        ENABLE_UART2_TXD_P30;  
 477   1        UART2_Open(24000000,115200); //Open uart2
 478   1      //  DISABLE_UART2_INTERRUPT;
 479   1        
 480   1        
 481   1        //uart1 - sim
 482   1        P10_QUASI_MODE;
 483   1        P00_INPUT_MODE;
 484   1        ENABLE_UART1_TXD_P10;
 485   1        ENABLE_UART1_RXD_P00;
 486   1        UART_Open(24000000,UART1_Timer3,115200);
 487   1        
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 9   

 488   1        DISABLE_UART1_INTERRUPT;
 489   1        
 490   1        //uart0 - esp
 491   1        P07_INPUT_MODE;
 492   1        P06_QUASI_MODE;
 493   1        UART_Open(24000000,UART0_Timer1,115200);
 494   1      //  ENABLE_UART0_PRINTF;
 495   1        DISABLE_UART0_INTERRUPT;
 496   1        
 497   1        //test esp - sim
 498   1        //P10_INPUT_MODE;
 499   1        //P00_INPUT_MODE;
 500   1        
 501   1      //    TIMER2_DIV_128;
 502   1      //    TIMER2_DIV_512;
 503   1      //    TIMER2_Auto_Reload_Delay_Mode;
 504   1      //    //1s
 505   1      ////    RCMP2H = 0x48;
 506   1      ////    RCMP2L = 0xF5;
 507   1      //    TL2 = 0x48;
 508   1      //    TH2 = 0xF5;
 509   1      //    //1ms
 510   1      ////    RCMP2H = 0xFF;
 511   1      ////    RCMP2L = 0x44;
 512   1      ////    TL2 = 0xFF;
 513   1      ////    TH2 = 0x44;
 514   1      //    ENABLE_TIMER2_INTERRUPT;
 515   1      //    ENABLE_GLOBAL_INTERRUPT;    
 516   1      //    set_EIE_ET2;                                    // Enable Timer2 interrupt
 517   1      //    set_IE_EA;
 518   1      //    set_T2CON_TR2;  
 519   1      
 520   1      //  ENABLE_TIMER1_MODE0;                           /* Timer 0 mode configuration */
 521   1      //    TIMER0_FSYS_DIV12;
 522   1      
 523   1      //    TH0 = 0x48;
 524   1      //    TL0 = 0xF5;
 525   1      //      
 526   1      //    ENABLE_TIMER0_INTERRUPT;                       /* enable Timer0 interrupt  */ 
 527   1      //    ENABLE_GLOBAL_INTERRUPT;                       /* enable interrupts */
 528   1      
 529   1      //    set_TCON_TR0;  
 530   1      
 531   1        TIMER2_DIV_512;
 532   1          TIMER2_Auto_Reload_Delay_Mode;
 533   1        
 534   1          RCMP2H = 0x48;
 535   1          RCMP2L = 0xF5;
 536   1      
 537   1          TL2 = 0x48;
 538   1          TH2 = 0xF5;
 539   1      
 540   1          set_EIE_ET2;                                    // Enable Timer2 interrupt
 541   1          set_IE_EA;
 542   1          set_T2CON_TR2;
 543   1      //    ENABLE_GLOBAL_INTERRUPT; 
 544   1          
 545   1          SET_INT_Timer2_LEVEL1;
 546   1          SET_INT_UART1_LEVEL2;
 547   1          SET_INT_UART0_LEVEL2;
 548   1          
 549   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 10  

 550          
 551          
 552          
 553          int waitResponse1(unsigned char *expect_str,int timeout){
 554   1        Tick=0;
 555   1        update=0;
 556   1        ID = 0;
 557   1        do{
 558   2          if(update==0){
 559   3            update=2;
 560   3            ENABLE_UART1_INTERRUPT;
 561   3            
 562   3          } else if(update==1){
 563   3            update = 0;
 564   3              
 565   3            ID = 0;
 566   3            if(strstr(RxUART,expect_str) != NULL){
 567   4              DISABLE_UART1_INTERRUPT;
 568   4              return 1;
 569   4            }
 570   3            else if(strstr(RxUART,"ERR") != NULL){
 571   4              DISABLE_UART1_INTERRUPT;
 572   4              return 2;
 573   4            }
 574   3          }
 575   2          delay_ms(10);
 576   2      //    Tick++;
 577   2        } while(Tick < timeout);
 578   1        DISABLE_UART1_INTERRUPT;
 579   1        return 0;
 580   1      }
 581          int waitResponse0(unsigned char *expect_str,int timeout){
 582   1        Tick=0;
 583   1        update=0;
 584   1        ID = 0;
 585   1        do{
 586   2          if(update==0){
 587   3            update=2;
 588   3            ENABLE_UART0_INTERRUPT;
 589   3            
 590   3          } else if(update==1){
 591   3            update = 0;
 592   3              
 593   3            ID = 0;
 594   3            if(strstr(RxUART,expect_str) != NULL){
 595   4              DISABLE_UART0_INTERRUPT;
 596   4              return 1;
 597   4            }
 598   3          }
 599   2          delay_ms(10);
 600   2        } while(Tick < timeout);
 601   1        DISABLE_UART0_INTERRUPT;
 602   1        return 0;
 603   1      }
 604          int waitResponse11(unsigned char *expect_str,int timeout){
 605   1        Tick=0;
 606   1        update=0;
 607   1        ID = 0;
 608   1        do{
 609   2          if(update==0){
 610   3            update=2;
 611   3            ENABLE_UART1_INTERRUPT;
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 11  

 612   3            
 613   3          } else if(update==1){
 614   3            update = 0;
 615   3              
 616   3            ID = 0;
 617   3            if(strstr(RxUART,expect_str) != NULL){
 618   4              DISABLE_UART1_INTERRUPT;
 619   4              return 1;
 620   4            }
 621   3            else if(strstr(RxUART,"OK") != NULL){
 622   4              DISABLE_UART1_INTERRUPT;
 623   4              return 1;
 624   4            }
 625   3            else if(strstr(RxUART,"ERR") != NULL){
 626   4              DISABLE_UART1_INTERRUPT;
 627   4              return 2;
 628   4            }
 629   3          }
 630   2          delay_ms(10);
 631   2      //    Tick++;
 632   2        } while(Tick < timeout);
 633   1        DISABLE_UART1_INTERRUPT;
 634   1        return 0;
 635   1      }
 636          void AutoEchoOFF(){
 637   1        memset(RxUART, '\0', 100);
 638   1        puts_UART1("ATE0\r\n");
 639   1        if(1 == waitResponse1("OK",20)){
 640   2          puts_UART2("EchoOFF OK");
 641   2        } else {
 642   2          puts_UART2("EchoOFF Fail");
 643   2        }
 644   1      }
 645          void GetInfo(){
 646   1        memset(RxUART, '\0', 100);
 647   1        puts_UART1("ATI\r\n");
 648   1        if(1 == waitResponse1("OK",50)){
 649   2          puts_UART2(RxUART);
 650   2        } else {
 651   2          puts_UART2("GetInfo Fail");
 652   2        }
 653   1      }
 654          void GetIMEI(){
 655   1        int i=0;
 656   1        puts_UART1("AT+GSN\r\n");
 657   1        ReadStringUntil(&bufffer,'\n',20);
 658   1        ReadStringUntil(&bufffer,'\n',20);
 659   1        for(i=0;i<15;i++){
 660   2          IMEI[i] = bufffer[i];
 661   2        }
 662   1        sprintf(M,"%s\n", bufffer);
 663   1        puts_UART2(M);
 664   1        delay_ms(20);
 665   1      }
 666          unsigned int readRSSI4G(){
 667   1        //AT+CSQ
 668   1        unsigned int ret = 101;
 669   1        char *ptr;
 670   1        int tmp;
 671   1        memset(RxUART, '\0', 100);
 672   1        puts_UART1("AT+CSQ\r\n");
 673   1        tmp = waitResponse11("CSQ:",5);
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 12  

 674   1        if(1 == tmp){
 675   2          //puts_UART2(RxUART);
 676   2          ptr = strstr(RxUART, "+CSQ:");
 677   2          sscanf(ptr, "+CSQ: %d", &ret);
 678   2        }
 679   1        delay_ms(100);
 680   1        return ret;
 681   1      }
 682          void readCREG(){
 683   1        //AT+CSQ
 684   1        memset(RxUART, '\0', 100);
 685   1        puts_UART1("AT+CREG?\r\n");
 686   1        if(1 == waitResponse1("CREG",2)){
 687   2          puts_UART2(RxUART);
 688   2        }
 689   1      }
 690          void ConnectNetwork(){
 691   1        memset(RxUART, '\0', 100);
 692   1        puts_UART1("AT+CGATT=1\r\n");
 693   1        if(1 == waitResponse1("OK",5)){
 694   2          puts_UART2(RxUART);
 695   2        }
 696   1        memset(RxUART, '\0', 100);
 697   1        puts_UART1("AT+CGDCONT=1,\"IP\",\"dialogbb\"\r\n");
 698   1        if(1 == waitResponse1("OK",5)){
 699   2          puts_UART2(RxUART);
 700   2        }
 701   1        memset(RxUART, '\0', 100);
 702   1        puts_UART1("AT+CGACT=1,1\r\n");
 703   1        if(1 == waitResponse1("OK",5)){
 704   2          puts_UART2(RxUART);
 705   2        }
 706   1        memset(RxUART, '\0', 100);
 707   1        puts_UART1("AT+CGPADDR=1\r\n");
 708   1        if(1 == waitResponse1("CGPADDR",5)){
 709   2          puts_UART2(RxUART);
 710   2        }
 711   1        delay_ms(100);
 712   1      }
 713          void simReset(){
 714   1        puts_UART1("AT+QRST=1\r\n");
 715   1        if(1 != waitResponse1("OK",2)){
 716   2          puts_UART2(M);
 717   2        }
 718   1      }
 719          int MQTT_Open(){
 720   1        memset(RxUART, '\0', 100);
 721   1        puts_UART1("AT+QMTCFG=\"recv/mode\",0,0,1\r\n");
 722   1        if(1 != waitResponse1("OK",2)){
 723   2          //puts_UART2(RxUART);
 724   2          return 1;
 725   2        }
 726   1      //  delay_ms(100);
 727   1      //  memset(RxUART, '\0', 100);
 728   1      //  puts_UART1("AT+QMTCFG=\"keepalive\",0,100\r\n");
 729   1      //  if(1 != waitResponse("OK",2)){
 730   1      //    return 2;
 731   1      //  }
 732   1      //  delay_ms(100);
 733   1      //  memset(RxUART, '\0', 100);
 734   1      //  puts_UART1("AT+QMTCFG=\"timeout\",0,60,10,1\r\n");
 735   1      //  if(1 != waitResponse("OK",2)){
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 13  

 736   1      //    return 3;
 737   1      //  }
 738   1        
 739   1      //  puts_UART1("AT+QMTOPEN=0,");
 740   1      //  puts_UART1(test_mqttServer);
 741   1      //  puts_UART1(",");
 742   1      //  //putc_UART1(test_mqttPort,1);
 743   1      //  sprintf(M,"%d\r\n",test_mqttPort);
 744   1        memset(RxUART, '\0', 100);
 745   1        sprintf(M,"AT+QMTOPEN=0,%s,%d\r\n",test_mqttServer,test_mqttPort);
 746   1        puts_UART1(M);
 747   1        if(1 != waitResponse11("QMTOPEN:",2)){
 748   2          //puts_UART2(RxUART);
 749   2          return 4;
 750   2        }
 751   1        delay_ms(100);
 752   1      //  puts_UART1("AT+QMTCONN=0,");
 753   1      //  puts_UART1(ESP_ID);
 754   1      //  puts_UART1(",");
 755   1      //  puts_UART1(mqttUser);
 756   1      //  puts_UART1(",");
 757   1      //  puts_UART1(mqttPassword);
 758   1      //  puts_UART1("\r\n");
 759   1      //  puts_UART1("AT+QMTCONN=0,\"94E6862F1EA0\",\"lctech_dev\",\"lctech_DEV@123\"\r\n");
 760   1        memset(RxUART, '\0', 100);
 761   1        sprintf(M,"AT+QMTCONN=0,\"%s\",%s,%s\r\n",ESPID,mqttUser,mqttPassword);
 762   1        puts_UART1(M);
 763   1        if(1 != waitResponse11("QMTCONN:",2)){
 764   2          //puts_UART2(RxUART);
 765   2          return 5;
 766   2        }
 767   1        delay_ms(100);
 768   1        return 0;
 769   1      }
 770          int MQTT_Publish(){
 771   1        ////869373068197954
 772   1      //  int i=0;
 773   1        memset(RxUART, '\0', 100);
 774   1      //  puts_UART1("AT+QMTSUB=0,1,\"mmm/94E6862F1EA0/cmd\",0\r\n");
 775   1        sprintf(M,"AT+QMTSUB=0,1,%s,0\r\n",txt_subscribe);
 776   1        puts_UART1(M);
 777   1        if(1 != waitResponse11("QMTSUB:",2)){
 778   2          //puts_UART2(RxUART);
 779   2          return 1;
 780   2        }
 781   1        delay_ms(100);
 782   1        //AT+QMTPUBEX=0,0,0,0,(char*)topic_srv,String(length)
 783   1      //  puts_UART1("AT+QMTPUBEX=0,1,1,0,\"swm/gsafe4/data\",16\r\n");
 784   1        memset(RxUART, '\0', 100);
 785   1        sprintf(M,"AT+QMTPUBEX=0,1,1,0,%s,%d\r\n",topicSever,(int)69);
 786   1        puts_UART1(M);
 787   1        if(1 != waitResponse1(">",2)){
 788   2          //puts_UART2(RxUART);
 789   2          //return 2;
 790   2        }
 791   1      //  Receive_Data(UART1);
 792   1        //send fdata to mqtt
 793   1      //  putc_UART1(send,18);
 794   1        memset(RxUART, '\0', 100);
 795   1        puts_UART1(HexString);
 796   1        
 797   1        if(1 == waitResponse1("OK",2)){
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 14  

 798   2          //return 3;
 799   2        }
 800   1        delay_ms(100);
 801   1      //  puts_UART1("AT+QMTDISC=0\r\n");
 802   1        return 0;
 803   1      }
 804          char h2c(char c){  
 805   1        return "0123456789ABCDEF"[0x0F & (unsigned char)c];
 806   1      }
 807          uint8_t updateHexString(uint8_t value, uint8_t index){
 808   1        HexString[index++]=h2c(value>>4);
 809   1        HexString[index++]=h2c(value&0x0F);
 810   1        return(index);
 811   1      }
 812          void updateData2Sent(){
 813   1        uint8_t index = 0;
 814   1        int line = 0;
 815   1        int sum = 0;
 816   1        gdata.rssi4G = readRSSI4G();
 817   1      //  gdata.rssi4G = 255;
 818   1        for(line=0;line<15;line++){
 819   2          dataload[index++] = IMEI[line];
 820   2        }
 821   1        for(line=0;line<12;line++){
 822   2          dataload[index++] = ESPID[line];
 823   2        }
 824   1        dataload[index++] = gdata.pwStatus; 
 825   1        dataload[index++] = gdata.batPercent;
 826   1        dataload[index++] = gdata.Status;
 827   1        dataload[index++] = gdata.rssi4G;
 828   1        dataload[index++] = gdata.rssiWF; 
 829   1        for(line = 0; line < 16; line++)
 830   1        {    
 831   2          dataload[index++]= gdata.lineStatus[line];
 832   2        }
 833   1        //hexstring
 834   1        index = 0;
 835   1        for(line = 0; line < 27; line++)
 836   1        {    
 837   2          HexString[index++] = dataload[line];
 838   2        }
 839   1        index = updateHexString(dataload[27],index);
 840   1        index = updateHexString(dataload[28],index);
 841   1        index = updateHexString(dataload[29],index);
 842   1        index = updateHexString(dataload[30],index);
 843   1        index = updateHexString(dataload[31],index);
 844   1        for(line = 32 ; line < 48; line++)
 845   1        {    
 846   2          index = updateHexString(dataload[line],index);
 847   2        }
 848   1        for(line =0;line<69;line++){
 849   2          sum= sum+HexString[line];
 850   2        }
 851   1        HexString[index++] = (uint8_t)sum;
 852   1        HexString[index++] = '\n';
 853   1        HexString[index++] = '\0';
 854   1      }
 855          void send2ESP(){
 856   1        updateData2Sent();
 857   1        puts_UART0("Data:");
 858   1        puts_UART0(HexString);
 859   1        delay_ms(10);
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 15  

 860   1      } 
 861          
 862          void getRssiWF(){
 863   1        char *ptr;
 864   1        memset(RxUART, '\0', 100);
 865   1        if(1==waitResponse0("WF",2)){
 866   2          ptr = strstr(RxUART, "WF:");
 867   2          sscanf(ptr, "WF:%d", &gdata.rssiWF);
 868   2      //    sprintf(M,"rssiWWF: %d\n",gdata.rssiWF);
 869   2      //    puts_UART2(M);
 870   2        }
 871   1        delay_ms(100);
 872   1      }
 873          void getESPID(){
 874   1        char *ptr;
 875   1        memset(RxUART, '\0', 100);
 876   1        if(1==waitResponse0("ID",5)){
 877   2          ptr = strstr(RxUART, "ID:");
 878   2          //ptr += 3;
 879   2          sscanf(ptr, "ID:%s", ESPID);
 880   2      //    sscanf(ptr, "%s", ESPID);
 881   2        }
 882   1        delay_ms(100);
 883   1        sprintf(M,"ID:%s\r\n",ESPID);
 884   1        puts_UART2(M);
 885   1      }
 886          char power_status;
 887          unsigned int RSSI = 1 ;
 888          //----------------------------------------------------MAIN------------------------------------------------
             -------//
 889          int sp=0;
 890          unsigned int IN16M;
 891          void Send2Server(){
 892   1        if(MQTT_Open() == 0){
 893   2            puts_UART2("Open Mqtt 4G OK");
 894   2          } else {
 895   2            puts_UART2("Open Mqtt 4G False");
 896   2            }
 897   1          if(MQTT_Publish() == 0){
 898   2            puts_UART2("Send Mqtt 4G OK");
 899   2            gdata.rssiInit = 5;
 900   2            sp = 0;
 901   2          } else {
 902   2            puts_UART2("Send Mqtt 4G False");
 903   2            gdata.rssiInit +=5;
 904   2            }
 905   1      }
 906          void main (void)
 907          {
 908   1        
 909   1        Tick = 0;
 910   1        GPIO_Init();
 911   1        DC_ON = 1;
 912   1        CH_OFF = 0; 
 913   1        EN_WIFI = 0;
 914   1        delay_ms(800);
 915   1        EN_WIFI = 1;
 916   1        delay_ms(10);
 917   1        getESPID();
 918   1        delay_ms(1000);
 919   1        GetIMEI();
 920   1        gdata.rssiWF = 255;
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 16  

 921   1        gdata.enableBell = 0;
 922   1        gdata.rssiInit = 5;
 923   1        AutoEchoOFF();
 924   1        ConnectNetwork();
 925   1      //------------------------------------------------WHILE(1)------------------------------------------------
             -------//  
 926   1        while(1)
 927   1        {
 928   2          delay_ms(10);
 929   2          controlPower();
 930   2          IN16M = check_IN16M();
 931   2          checkAlarm();
 932   2          /* COMM WITH ESP */
 933   2          send2ESP();   //send to esp
 934   2      //    sprintf(M,"RSSI:%d\n",gdata.rssiInit);  //send rssiInit to esp
 935   2      //    puts_UART0(M);
 936   2          delay_ms(20);
 937   2          getRssiWF();  //read rssiWF from esp
 938   2          /* SELF */
 939   2          sprintf(M,"SP:%d    %d\n",(int)gdata.rssiInit,(int)sp);
 940   2          puts_UART2(M);
 941   2          if(gdata.rssiInit >  100) gdata.rssiInit =5;
 942   2          //send to sv
 943   2          if(gdata.rssiWF < 125 | gdata.rssiWF !=0){
 944   3            if(sp > 300){
 945   4              Send2Server();
 946   4              sp = 0;
 947   4            } 
 948   3          } else {
 949   3            if(gdata.Status == ALARM){
 950   4              if(sp >= 10){
 951   5                Send2Server();
 952   5              }
 953   4            } else {
 954   4              if(sp >= 30){
 955   5                Send2Server();
 956   5              }
 957   4            }
 958   3          }
 959   2        }
 960   1      }
 961          
 962          void Timer2_ISR (void) interrupt 5
 963          {
 964   1        
 965   1          PUSH_SFRS;
 966   1          clr_T2CON_TF2; 
 967   1          sp++;
 968   1          Tick++;
 969   1          readADC_16line();
 970   1          
 971   1          if(gdata.Status == ALARM){
 972   2            LED_GREEN = 1;
 973   2            LED_RED = ~LED_RED;
 974   2          } else {
 975   2            LED_RED = 1;
 976   2            LED_GREEN = ~LED_GREEN;
 977   2          }
 978   1          POP_SFRS;
 979   1      } 
 980          void SerialPort1_ISR(void) interrupt 15
 981          {
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 17  

 982   1        char dataIn;
 983   1        PUSH_SFRS;
 984   1          
 985   1          if (RI_1 == 1)
 986   1          {
 987   2            dataIn = SBUF_1;
 988   2              
 989   2              if(dataIn != '\r' & dataIn>0){
 990   3                RxUART[ID] = dataIn;
 991   3                ID++;
 992   3              }
 993   2              else if (dataIn == '\r' && ID>0)
 994   2              {
 995   3                update=1;
 996   3            //    sprintf(M,"%s\r\n",RxUART);
 997   3          //for(i=0;i<ID,i++)
 998   3          //      puts_UART2(M);
 999   3                
1000   3              }
1001   2            //uart1_receive_data = SBUF_1;
1002   2              clr_SCON_1_RI_1;                             /* clear reception flag for next reception */
1003   2              //uart1_receive_flag = 1;
1004   2          }
1005   1      
1006   1          if (TI_1 == 1)
1007   1          {
1008   2              if (!PRINTFG)
1009   2              {
1010   3                  clr_SCON_1_TI_1;                             /* if emission occur */
1011   3              }
1012   2          }
1013   1          POP_SFRS;
1014   1      } 
1015          void Serial_ISR(void) interrupt 4
1016          {
1017   1        char dataIn;
1018   1          PUSH_SFRS;
1019   1          if (RI)
1020   1          {
1021   2              dataIn = SBUF;
1022   2              
1023   2              if(dataIn != '\r' & dataIn>0){
1024   3                RxUART[ID] = dataIn;
1025   3                ID++;
1026   3              }
1027   2              else if (dataIn == '\r' && ID>0)
1028   2              {
1029   3                update=1;
1030   3                }
1031   2      //        uart0_receive_flag = 1;
1032   2      //        uart0_receive_data = SBUF;
1033   2              clr_SCON_RI;                                            // Clear RI (Receive Interrupt).
1034   2          }
1035   1      
1036   1          if (TI)
1037   1          {
1038   2      //        if (!PRINTFG)
1039   2      //        {
1040   2      //            TI = 0;
1041   2      //        }
1042   2          }
1043   1          POP_SFRS;
C51 COMPILER V9.60.7.0   MAIN                                                              04/10/2025 12:58:43 PAGE 18  

1044   1      }  
1045          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6013    ----
   CONSTANT SIZE    =    590    ----
   XDATA SIZE       =    693      64
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
